# -*- coding: utf-8 -*-
"""HW2-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y_yI2YBd3c6D_ZbyMCXNw98Ps_HyH58r
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
import os
from google.colab.patches import cv2_imshow
import math
from os import listdir
import random
from functools import reduce

from google.colab import drive
drive.mount('/content/drive')

def getPts(path):
  points = []
  fh = open(path)
  p = fh.readlines()
  for point in p:
    coord = point.split()
    points.append([float(coord[0]), float(coord[1]), 1])
  return points

def LeastSquare8Point(points, n):
  pts1 = [[a, b, 1] for a, b, c, d in points]
  pts2 = [[c, d, 1] for a, b, c, d in points]

  # create a n*9 matrix to compute the fundamental matrix
  A = np.zeros((n, 9))
  for i in range(n):
    A[i][0] = points[i][0] * points[i][2]
    A[i][1] = points[i][0] * points[i][3]
    A[i][2] = points[i][0]
    A[i][3] = points[i][1] * points[i][2]
    A[i][4] = points[i][1] * points[i][3]
    A[i][5] = points[i][1]
    A[i][6] = points[i][2]
    A[i][7] = points[i][3]
    A[i][8] = 1

  # decompose A to obtain the fundamental matrix
  u, s, v = np.linalg.svd(A)
  f = v[-1].reshape(3, 3)
  u, s, v = np.linalg.svd(f)
  # force f a rank two matrix
  s[2] = 0
  f = u @ np.diag(s) @ v
  
  return f

def drawPointsAndLines(img1, img2, points, f):
  distance = 0
  h, w = img1.shape[:2]
  for x1, y1, x2, y2 in points:
    # use f to compute the corresponding epipolar lines
    a1, b1, c1 = f.transpose() @ np.array([x1, y1, 1])
    a2, b2, c2 = f @ np.array([x2, y2, 1])
    # measure the distance between points and lines
    distance += abs(a1*x2 + b1*y2 + c1) / ((a1**2 + b1**2)**0.5)
    distance += abs(a2*x1 + b2*y1 + c2) / ((a2**2 + b2**2)**0.5)
    # draw lines
    p1, p2 = (0, int(-c1/b1)), (w, int(-(a1*w + c1)/b1))
    p3, p4 = (0, int(-c2/b2)), (w, int(-(a2*w + c2)/b2))
    cv2.line(img1, p3, p4, (0, 0, 255), 1)
    cv2.line(img2, p1, p2, (0, 0, 255), 1)
  
  for x1, y1, x2, y2 in points:
    # draw points
    cv2.circle(img1, (int(x1), int(y1)), 2, (0,255,0), 2)
    cv2.circle(img2, (int(x2), int(y2)), 2, (0,255,0), 2)
    
  print('Average distance = %f' % (distance / (2 * len(pts1))))
  return img1, img2

img1 = cv2.imread('/content/drive/MyDrive/HW2/image1.jpg')
img2 = cv2.imread('/content/drive/MyDrive/HW2/image2.jpg')

# '46' on the first lines of pt_2D_1.txt and pt_2D_2.txt were removed.
pts1 = getPts('/content/drive/MyDrive/HW2/pt_2D_1.txt')
pts2 = getPts('/content/drive/MyDrive/HW2/pt_2D_2.txt')
p = []
for i in range(len(pts1)):
  p.append([pts1[i][0], pts1[i][1], pts2[i][0], pts2[i][1]])

# Compute the fundmental matrix
f = LeastSquare8Point(p, len(p))
print('Fundamental Matrix for Least Square 8-point algorithm:')
print(f)
# Draw points and epipolar lines
img1, img2 = drawPointsAndLines(img1, img2, p, f)

cv2.imwrite('a_img1.jpg', img1)
cv2.imwrite('a_img2.jpg', img2)

"""**1(b)**"""

def normalize(p):
  n = len(p)
  p1, p2 = [[], []], [[], []]
  points = []
  for a,b,c,d in p:
    p1[0].append(a)
    p1[1].append(b)
    p2[0].append(c)
    p2[1].append(d)
  
  mean1 = np.mean(p1, axis=1)
  S1 = np.sqrt(2) / np.std(p1[0])
  S2 = np.sqrt(2) / np.std(p1[1])
  T1 = np.array([[S1, 0, -S1 * mean1[0]],
           [0, S2, -S2 * mean1[1]],
           [0, 0, 1]])
  
  mean2 = np.mean(p2, axis=1)
  S1 = np.sqrt(2) / np.std(p2[0])
  S2 = np.sqrt(2) / np.std(p2[1])
  T2 = np.array([[S1, 0, -S1 * mean2[0]],
           [0, S2, -S2 * mean2[1]],
           [0, 0, 1]])
  
  # use T1 and T2 to normalized points
  for a,b,c,d in p:
    x1,y1,z1 = T1 @ np.array([a, b, 1])
    x2,y2,z2 = T2 @ np.array([c, d, 1])
    points.append([x1/z1, y1/z1, x2/z2, y2/z2])

  return points, T1, T2

def normalized8Points(points):
  p, T1, T2 = normalize(points)
  # use normalized points to compute F
  resultFund = LeastSquare8Point(p, len(p))
  return T1.transpose() @ resultFund @ T2

img1 = cv2.imread('/content/drive/MyDrive/HW2/image1.jpg')
img2 = cv2.imread('/content/drive/MyDrive/HW2/image2.jpg')
pts1 = getPts('/content/drive/MyDrive/HW2/pt_2D_1.txt')
pts2 = getPts('/content/drive/MyDrive/HW2/pt_2D_2.txt')
p = []
for i in range(len(pts1)):
  p.append([pts1[i][0], pts1[i][1], pts2[i][0], pts2[i][1]])

f = normalized8Points(p)
print('Fundamental Matrix for normalized 8-point algorithm:')
print(f)
img1, img2 = drawPointsAndLines(img1, img2, p, f)

cv2.imwrite('b_img1.jpg', img1)
cv2.imwrite('b_img2.jpg', img2)